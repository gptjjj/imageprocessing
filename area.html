<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Small Business - Start Bootstrap Template</title>
        <!-- Favicon-->
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>



        <script>
            //////////////////
            //전역 변수부
            /////////////////
            let inCanvas, inCtx, inPaper //입력 영상 관련
            let outCanvas, outCtx, outPaper //출력 영상 관련
            let inImage, inH, inW; // 2차원배열, 높이, 폭
            let outImage, outH, outW; // 2차원배열, 높이, 폭
            let inFile;
    
            //////////////////
            //공통 변수부: open(), display()
            /////////////////
    
            function init(){
                //초기화 함수
                inCanvas = document.getElementById("inCanvas");  //도화지
                inCtx = inCanvas.getContext("2d"); //물감, 붓이 들은 통
    
                outCanvas = document.getElementById("outCanvas");  //도화지
                outCtx = outCanvas.getContext("2d"); //물감, 붓이 들은 통
                //alert("init() 확인!"); //여기까지 잘됐는지 확인!
                
            }
    
            function openImage() {
                inFile = document.getElementById("inFile").files[0]; //선택한 raw파일
                //(중요!!코드) 선택한 이미지의 크기를 확인
                inH = inW = Math.sqrt(inFile.size); // 파일 크기 관계없이 다 처리됨
                //raw파일의 이미지는 정사각형으로 제한됨
                // 이미지 크기의 메모리(2차원배열)를 확보
                inImage = new Array(inH);
                for(let i=0;i<inH;i++)
                    inImage[i] = new Array(inW);
                // 파일 --> 메모리
                let reader = new FileReader();
                reader.readAsBinaryString(inFile);
                reader.onload = function () {
                    let blob = reader.result; //파일을 한 덩어리(blob)으로 가져옴, js에서만 사용
                    //덩어리(blob)에서 한점한점 뽑아서, 배열에 넣기..?몇번 반복?512*512
                    for (let i=0;i<inH;i++){
                        for (let k=0;k<inW;k++){
                            let sPixel = (i*inH + k); //시작 위치
                            let ePixel = (i*inH + k)+1; //끝 위치
                            inImage[i][k] = blob.slice(sPixel,ePixel).charCodeAt(0); //0~1까지 뽑아라.0만 뽑힘.
                          }
                    }
                    //도화지 크기를 이미지 크기로 조절
                    inCanvas.height = inH;
                    inCanvas.width = inW;
                    //**입력 메모리(inImage)를 페이퍼에 콕콕 찍어서 출력한 후 페이퍼를 캠퍼스에 딱 붙이기
                    inPaper = inCtx.createImageData(inH,inW); //이미지 크기의 빈 종이를 준비
                    for (let i=0;i<inH;i++){
                        for (let k=0;k<inW;k++){
    
                            let px = inImage[i][k]; //'뙓'-->223 숫자로 변형시켜야함
                            inPaper.data[(i*inH + k)*4 + 0] = px; //red
                            inPaper.data[(i*inH + k)*4 + 1] = px; //green
                            inPaper.data[(i*inH + k)*4 + 2] = px; //blue
                            inPaper.data[(i*inH + k)*4 + 3] = 255; //Alpha (투명도)
                        }
                    }
                    inCtx.putImageData(inPaper,0,0);
                }
            }
    
            function displayImage() {
                outCanvas.height = outH;
                outCanvas.width = outW;
                //**입력 메모리(inImage)를 페이퍼에 콕콕 찍어서 출력한 후 페이퍼를 캠퍼스에 딱 붙이기
                outPaper = outCtx.createImageData(outH,outW); //이미지 크기의 빈 종이를 준비
    
                for (let i=0;i<outH;i++){
                    for (let k=0;k<outW;k++){
                        let px = outImage[i][k]; //'뙓'-->223 숫자로 변형시켜야함
                        outPaper.data[(i*outH + k)*4 + 0] = px; //red
                        outPaper.data[(i*outH + k)*4 + 1] = px; //green
                        outPaper.data[(i*outH + k)*4 + 2] = px; //blue
                        outPaper.data[(i*outH + k)*4 + 3] = 255; //Alpha (투명도)
                    }
                }
                outCtx.putImageData(outPaper,0,0);
            }
    
            function selectAlgorithm(selNum) {
    
                switch (parseInt(selNum.value)) {
                    case 101 : //동일영상
                        equalImage();  break;
                    case 102 : //반전영상
                        reverseImage(); break;
                    case 103 : //곱하기
                        mulImage();  break;
                    case 104 : //나누기
                        divImage(); break;
                    case 105 : //더하기
                        addImage();  break;
                    case 106 : //빼기
                        minusImage(); break;
                    case 107 : //흑백
                        blackAvgImage();  break;
                    case 108 : //파라볼라(캡)
                        capImage(); break;
                    case 109 : //파라볼라(컵)
                        cupImage();  break;
                    case 110 : //감마
                        gammaImage();  break;
                    case 201 : //상하 미러링
                        upndownImage(); break;
                    case 202 : //좌우 미러링
                        leftnrightImage(); break;
                    case 203 : //축소
                        zoomOutImage(); break;
                    case 204 : //확대
                        zoomInImage2(); break;
                    case 205 : //이동
                        moveImage(); break;
                    case 206 : //회전
                        rotateImage(); break;
                    case 301 : //엠보싱
                        embossImage(); break;
                    case 302 : //블러링
                        blurImage(); break;
                    case 303 : //가우시안
                        gaussianImage(); break;
                    case 304 : //샤프닝
                        sharpImage(); break;
                    case 305 : //고주파 필터 샤프닝
                        onHpfSharpImage(); break;
                    case 306 : //엣지 검출
                        edgeImage(); break; 
                    case 307 : //엣지 검출(라플라시안)
                        laplaImage(); break; 
                    case 308 : //Laplacian of Gaussian
                        LoGImage(); break; 
                    case 309 : //difference of Gaussian(Dog)
                        DoGImage(); break;
                    case 401 : //스트레칭
                        stretchImage(); break; 
                    case 402 : //엔드-인탐색
                        endInImage(); break;
                    case 403 : //평활화
                        equalizeImage(); break;
                        
                } 
            }
    
            //////////////////
            //**영상 처리 함수부**
            /////////////////
    
            function equalImage() {   //동일 영상 알고리즘
                // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
                outH = inH;
                outW = inW;
    
                //출력 영상의 2차원 메모리 할당
                outImage = new Array(outH);
                for(let i=0;i<outH;i++)
                    outImage[i] = new Array(outW);
                // ****진짜 영상처리 알고리즘*****
                for (let i=0;i<inH;i++){
                    for (let k=0;k<inW;k++){
                        outImage[i][k] = inImage[i][k];
                    }
                //*********************************
                }displayImage();
            }
    
            function reverseImage() {  //반전 
                 // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
                outH = inH;
                outW = inW;
                //출력 영상의 2차원 메모리 할당
                outImage = new Array(outH);
                for(let i=0;i<outH;i++)
                    outImage[i] = new Array(outW);
                // ****진짜 영상처리 알고리즘*****
                for (let i=0;i<inH;i++){
                    for (let k=0;k<inW;k++){
                        outImage[i][k] = 255-inImage[i][k];
                    }
                }
                displayImage();
            }
    
    
            function mulImage() {
            // 영상 산술처리하기 (곱셈)
            let value = parseInt(prompt("곱할 값 :", "2"));
            for (let i = 0; i < outH; i++) {
              for (let k = 0; k < outW; k++) {
                if (outImage[i][k] * value > 255) outImage[i][k] = 255;
                else outImage[i][k] = inImage[i][k] * value;
              }
            }
            displayImage();
          }
    
          function divImage() {
            // 영상 산술처리하기 (나눗셈)
            let value = parseInt(prompt("나눌 값 :", "2"));
            for (let i = 0; i < outH; i++) {
              for (let k = 0; k < outW; k++) {
                if (outImage[i][k] / value <= 0) outImage[i][k] = 0;
                else outImage[i][k] = inImage[i][k] / value;
              }
            }
            displayImage();
          }
    
            
        //밝게
        function addImage() {
    
                let value = parseInt(prompt("숫자 :","100"));
                for(let i=0;i<outH;i++){
                    for(let k=0;k<outW;k++){
                        if(outImage[i][k] + value >255)
                        outImage[i][k]=255;
                        else
                        outImage[i][k] += value;
                    }
                }
                displayImage();
            }
    
    
        //어둡게
        function minusImage(){
            let value = parseInt(prompt("숫자 :","-100"));
            for(let i=0;i<outH;i++){
                for(let k=0;k<outW;k++){
                    if(outImage[i][k] + value <0)
                    outImage[i][k]=0;
                    else
                    outImage[i][k] += value;
                }
            }
            displayImage();
        }
    
    
        //평균을 기준으로 영상을 흑백처리
        function blackAvgImage() {
            let avg, sum = 0;
            for(let i=0;i<outH;i++){
                for(let k=0;k<outW;k++){
                    sum+=outImage[i][k];
                }
            }
            avg = sum/(outH*outW);
            for(let i=0;i<outH;i++){
                for(let k=0;k<outW;k++){
                    if(outImage[i][k]<avg){
                        outImage[i][k]=0;
                    }else {
                        outImage[i][k]=255;
                    }
                }
            }displayImage();
        }
    
        //밝은 곳을 입체화하는 Cap 함수  = 솔라리징 변환
        function capImage() {
            outH = inH;
            outW = inW;
            outImage = new Array(outH);
            for (var i=0; i<outH; i++)
                outImage[i] = new Array(outW);
    
            for (var i=0; i<inH; i++) {
                for (var k=0; k<inW; k++) {
                    outImage[i][k] = 255-255*Math.pow((inImage[i][k]/127-1), 2);
                }
            }
            displayImage();
        }
    
        //어두운 곳을 입체화 하는 cup 합수
        function cupImage() {
            outH = inH;
            outW = inW;
            outImage = new Array(outH);
            for (var i=0; i<outH; i++)
                outImage[i] = new Array(outW);
    
            for (var i=0; i<inH; i++) {
                for (var k=0; k<inW; k++) {
                    outImage[i][k] = 255*Math.pow((inImage[i][k]/127-1), 2);
                }
            }
            displayImage();
        }
    
        function gammaImage() {
        // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
        outH = inH;
        outW = inW;
        let gamma = parseInt(prompt("숫자: ","2"));
    
        //출력 영상의 2차원 메모리 할당
        outImage = new Array(outH);
        for(let i=0;i<outH;i++)
            outImage[i] = new Array(outW);
        // ****진짜 영상처리 알고리즘*****
        for (let i=0;i<inH;i++){
            for (let k=0;k<inW;k++){
                outImage[i][k] = Math.pow(inImage[i][k]/255,gamma)*255;
            }
        }displayImage();
        }
    
        /////////////////////
        //기하학 처리
        ////////////////////
    
        //상하반전미러링
        function upndownImage() {
            for (let i = 0; i < outH / 2; i++) {
            for (let k = 0; k < outW; k++) {
                pixel = outImage[i][k];
                changeValue = outImage[outH - i - 1][k];
                outImage[i][k] = changeValue;
                outImage[outH - i - 1][k] = pixel;
            }
            }
            displayImage();
        }
    
    
        //좌우반전 미러링
        function leftnrightImage() {
            for (let i = 0; i < outH; i++) {
            for (let k = 0; k < outW / 2; k++) {
                pixel = outImage[i][k];
                changeValue = outImage[i][outW - k - 1];
                outImage[i][k] = changeValue;
                outImage[i][outW - k - 1] = pixel;
                }
            }
            displayImage();
        }
    
        function zoomOutImage() {   //축소알고리즘
            let scale = parseInt(prompt("배율",2));
            outH = parseInt(inH/scale);
            outW = parseInt(inW/scale);
    
            //출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0;i<outH;i++)
                outImage[i] = new Array(outW);
            // ****진짜 영상처리 알고리즘*****
            for (let i=0;i<inH;i++){
                for (let k=0;k<inW;k++){
                    outImage[parseInt(i/scale)][parseInt(k/scale)] = inImage[i][k];
                }
            }displayImage();
        }
    
        function zoomInImage2(){ //확대 알고리즘 , 백워딩
        let scale = parseInt(prompt("배율",2));
        outH = parseInt(inH*scale);
        outW = parseInt(inW*scale);
    
        //출력 영상의 2차원 메모리 할당
        outImage = new Array(outH);
        for(let i=0;i<outH;i++)
            outImage[i] = new Array(outW);
        // ****진짜 영상처리 알고리즘*****
        for (let i=0;i<outH;i++){
            for (let k=0;k<outW;k++){
                outImage[i][k] = inImage[parseInt(i/scale)][parseInt(k/scale)];
                }
            }displayImage();
            }
    
    
    
        function moveImage() { //이동 알고리즘
            outH = inH;
            outW = inW;
            outImage = new Array(outH);
            for (var i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            outCanvas.height = outH;
            outCanvas.width = outW;  
            var value_2 = parseInt(prompt("이동위치", "x, 가로이동값 -->"));
            var value_1 = parseInt(prompt("이동위치", "y, 세로이동값 -->"));
            for (var i=0; i<outH; i++) {
                for (var k=0; k<outW; k++) {
                    if (i+value_1 < outCanvas.height && k+value_2 < outCanvas.width)
                    outImage[i+value_1][k+value_2] = inImage[i][k];
                    else outImage[i][k] === undefined;
                }
            }
            displayImage();
            }
    
    
        // 값을 입력받아 회전하는 함수
        function rotateImage() { // 회전 알고리즘
            
            let value = parseInt(prompt("회전각", "45"));
            let radian = value * Math.PI / 180.0;
    
            
    
            outH = parseInt(Math.abs(Math.cos(radian)*inH) + Math.abs(Math.cos(Math.PI/2-radian)*inW));
            outW = parseInt(Math.abs(Math.cos(radian)*inW) + Math.abs(Math.cos(Math.PI/2-radian)*inH));
            outImage = new Array(outH);
            for (var i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            //출력 배열을 0으로 초기화
            for(let i=0;i<outH;i++){
                for(let k=0;k<outW;k++){
                    outImage[i][k]=255;
                }
            }
    
            let xd, yd;  //이미지를 이동시킬 목적지 좌표
            let xs, ys;  //x, y의 시작점
            let cx = parseInt(outH / 2);  //이미지의 중심 좌표값
            let cy = parseInt(outW / 2);  //이미지의 중심 좌표값
            for (let i=0; i<outH; i++) {
                for (let k=0; k<outW; k++) {
                    xs = i;  
                    ys = k;  
                    xd = parseInt(Math.cos(radian) * (xs - cx)
                    - Math.sin(radian) * (ys - cy) + cx / outH * inH);
                    yd = parseInt(Math.sin(radian) * (xs - cx) 
                    + Math.cos(radian) * (ys-cy)+cy /outW * inW);
                    
                    if ((0 <= xd && xd < inH) && (0 <= yd && yd < inW))
                    outImage[xs][ys] = inImage[xd][yd];
                    else outImage[xs][ys] === undefined;
    
                    
                }
            }
            displayImage();
        }
    
        function embossImage() {  //엠보싱 알고리즘
            // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
            outH = inH;
            outW = inW;
            //출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0;i<outH;i++)
                outImage[i] = new Array(outW);
            // ****진짜 영상처리 알고리즘*****
            //(짱 중요함) -->마스크를 선택
            let mask = [    [-1.0 , 0.0 , 0.0],
                            [ 0.0 , 0.0 , 0.0],
                            [ 0.0 , 0.0 , 1.0]
                        ];
            //임시 입력 배열 (입력배열 +2)
            let tempInImage = new Array(inH+2);
            for(let i=0; i<inH+2;i++)
                tempInImage[i] =  new Array(inW+2);
    
            //임시 출력 배열 (출력배열과 크기 동일)
            let tempOutImage = new Array(outH);
            for(let i=0;i<outH;i++)
                tempOutImage[i] = new Array(outW);
            
            //임시 입력 배열 초기화(127로, 평균값, 인접값*)
            for (let i=0;i<inH+2;i++)
                for (let k=0;k<inW+2;k++)
                    tempInImage[i][k] = 127.0;
            //입력 이미지 > 임시 입력 이미지의 중간에 쏙
            for (let i=0;i<inH;i++)
                for (let k=0;k<inW;k++)
                    tempInImage[i+1][k+1] = inImage[i][k];
    
            //영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for (let i=0;i<inH;i++){
                for (let k=0;k<inW;k++){
                    //한점 처리
                    let S = 0.0; //9점을 곱해서 합한 결과
                    for (let m=0; m<3; m++)
                        for(let n=0; n<3; n++)
                            S += tempInImage[i+m][k+n] * mask[m][n];
                    tempOutImage[i][k] = S;
                }
            //*********************************
            }
            //후처리 작업 (마스크의 합계가 0이면 127정도를 더해주기를 고려)
            for (let i=0;i<outH;i++)
                for (let k=0;k<outW;k++)
                    tempOutImage[i][k] += 127.0;
    
            // 임시 출력 이미지 --> 원 출력 이미지
            for (let i=0;i<outH;i++)
                for (let k=0;k<outW;k++) {
                    if (tempOutImage[i][k] > 255.0)
                        outImage[i][k] = 255;
                    else if (tempOutImage[i][k] < 0.0)
                        outImage[i][k] = 0;
                    
                    else
                        outImage[i][k] = parseInt(tempOutImage[i][k]);
                }
            displayImage();
        }
    
        function blurImage() {  //블러링 알고리즘
            // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
            outH = inH;
            outW = inW;
            //출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0;i<outH;i++)
                outImage[i] = new Array(outW);
            // ****진짜 영상처리 알고리즘*****
            //(짱 중요함) -->마스크를 선택
            let mask = [    [ 1.0/9 , 1.0/9 , 1.0/9],
                            [ 1.0/9 , 1.0/9 , 1.0/9],
                            [ 1.0/9 , 1.0/9 , 1.0/9]
                        ];
            //임시 입력 배열 (입력배열 +2)
            let tempInImage = new Array(inH+2);
            for(let i=0; i<inH+2;i++)
                tempInImage[i] =  new Array(inW+2);
    
            //임시 출력 배열 (출력배열과 크기 동일)
            let tempOutImage = new Array(outH);
            for(let i=0;i<outH;i++)
                tempOutImage[i] = new Array(outW);
            
            //임시 입력 배열 초기화(127로, 평균값, 인접값*)
            for (let i=0;i<inH+2;i++)
                for (let k=0;k<inW+2;k++)
                    tempInImage[i][k] = 127.0;
            //입력 이미지 > 임시 입력 이미지의 중간에 쏙
            for (let i=0;i<inH;i++)
                for (let k=0;k<inW;k++)
                    tempInImage[i+1][k+1] = inImage[i][k];
    
            //영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for (let i=0;i<inH;i++){
                for (let k=0;k<inW;k++){
                    //한점 처리
                    let S = 0.0; //9점을 곱해서 합한 결과
                    for (let m=0; m<3; m++)
                        for(let n=0; n<3; n++)
                            S += tempInImage[i+m][k+n] * mask[m][n];
                    tempOutImage[i][k] = S;
                }
            //*********************************
            }
            // //후처리 작업 (마스크의 합계가 0이면 127정도를 더해주기를 고려)
            // for (let i=0;i<outH;i++)
            //     for (let k=0;k<outW;k++)
            //         tempOutImage[i][k] += 127.0;
    
            // 임시 출력 이미지 --> 원 출력 이미지
            for (let i=0;i<outH;i++)
                for (let k=0;k<outW;k++) {
                    if (tempOutImage[i][k] > 255.0)
                        outImage[i][k] = 255;
                    else if (tempOutImage[i][k] < 0.0)
                        outImage[i][k] = 0;
                    else
                        outImage[i][k] = parseInt(tempOutImage[i][k]);
                }
            displayImage();
        }
    
        function gaussianImage() {  //가우시안 블러링 알고리즘
            // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
            outH = inH;
            outW = inW;
            //출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0;i<outH;i++)
                outImage[i] = new Array(outW);
            // ****진짜 영상처리 알고리즘*****
            //(짱 중요함) -->마스크를 선택
            let mask = [    [ 1.0/16 , 1.0/8 , 1.0/16],
                            [ 1.0/8 ,  1.0/4 , 1.0/8],
                            [ 1.0/16 , 1.0/8 , 1.0/16]
                        ];
            //임시 입력 배열 (입력배열 +2)
            let tempInImage = new Array(inH+2);
            for(let i=0; i<inH+2;i++)
                tempInImage[i] =  new Array(inW+2);
    
            //임시 출력 배열 (출력배열과 크기 동일)
            let tempOutImage = new Array(outH);
            for(let i=0;i<outH;i++)
                tempOutImage[i] = new Array(outW);
            
            //임시 입력 배열 초기화(127로, 평균값, 인접값*)
            for (let i=0;i<inH+2;i++)
                for (let k=0;k<inW+2;k++)
                    tempInImage[i][k] = 127.0;
            //입력 이미지 > 임시 입력 이미지의 중간에 쏙
            for (let i=0;i<inH;i++)
                for (let k=0;k<inW;k++)
                    tempInImage[i+1][k+1] = inImage[i][k];
    
            //영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for (let i=0;i<inH;i++){
                for (let k=0;k<inW;k++){
                    //한점 처리
                    let S = 0.0; //9점을 곱해서 합한 결과
                    for (let m=0; m<3; m++)
                        for(let n=0; n<3; n++)
                            S += tempInImage[i+m][k+n] * mask[m][n];
                    tempOutImage[i][k] = S;
                }
            //*********************************
            }
            // //후처리 작업 (마스크의 합계가 0이면 127정도를 더해주기를 고려)
            // for (let i=0;i<outH;i++)
            //     for (let k=0;k<outW;k++)
            //         tempOutImage[i][k] += 127.0;
    
            // 임시 출력 이미지 --> 원 출력 이미지
            for (let i=0;i<outH;i++)
                for (let k=0;k<outW;k++) 
                    outImage[i][k] = parseInt(tempOutImage[i][k]);
                
            displayImage();
        }
    
        function sharpImage() {  //샤프닝 알고리즘
            // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
            outH = inH;
            outW = inW;
            //출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0;i<outH;i++)
                outImage[i] = new Array(outW);
            // ****진짜 영상처리 알고리즘*****
            //(짱 중요함) -->마스크를 선택
            let mask = [    [ -0.0 , -1.0 ,  0.0],
                            [ -1.0 ,  5.0 , -1.0],
                            [  0.0 , -1.0 ,  0.0]
                        ];
            //임시 입력 배열 (입력배열 +2)
            let tempInImage = new Array(inH+2);
            for(let i=0; i<inH+2;i++)
                tempInImage[i] =  new Array(inW+2);
    
            //임시 출력 배열 (출력배열과 크기 동일)
            let tempOutImage = new Array(outH);
            for(let i=0;i<outH;i++)
                tempOutImage[i] = new Array(outW);
            
            //임시 입력 배열 초기화(127로, 평균값, 인접값*)
            for (let i=0;i<inH+2;i++)
                for (let k=0;k<inW+2;k++)
                    tempInImage[i][k] = 127.0;
            //입력 이미지 > 임시 입력 이미지의 중간에 쏙
            for (let i=0;i<inH;i++)
                for (let k=0;k<inW;k++)
                    tempInImage[i+1][k+1] = inImage[i][k];
    
            //영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for (let i=0;i<inH;i++){
                for (let k=0;k<inW;k++){
                    //한점 처리
                    let S = 0.0; //9점을 곱해서 합한 결과
                    for (let m=0; m<3; m++)
                        for(let n=0; n<3; n++)
                            S += tempInImage[i+m][k+n] * mask[m][n];
                    tempOutImage[i][k] = S;
                }
            //*********************************
            }
            // //후처리 작업 (마스크의 합계가 0이면 127정도를 더해주기를 고려)
            // for (let i=0;i<outH;i++)
            //     for (let k=0;k<outW;k++)
            //         tempOutImage[i][k] += 127.0;
    
            // 임시 출력 이미지 --> 원 출력 이미지
            for (let i=0;i<outH;i++)
                for (let k=0;k<outW;k++) 
                    outImage[i][k] = parseInt(tempOutImage[i][k]);
                
            displayImage();
        }
    
    
        function onHpfSharpImage() {  //고주파 필터 샤프닝 알고리즘
            // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
            outH = inH;
            outW = inW;
            //출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0;i<outH;i++)
                outImage[i] = new Array(outW);
            // ****진짜 영상처리 알고리즘*****
            //(짱 중요함) -->마스크를 선택
            let mask = [    [ -1.0/9 , -1.0/9 ,  -1.0/9],
                            [ -1.0/9 ,  8.0/9 ,  -1.0/9],
                            [ -1.0/9 , -1.0/9 ,  -1.0/9]
                        ];
            //임시 입력 배열 (입력배열 +2)
            let tempInImage = new Array(inH+2);
            for(let i=0; i<inH+2;i++)
                tempInImage[i] =  new Array(inW+2);
    
            //임시 출력 배열 (출력배열과 크기 동일)
            let tempOutImage = new Array(outH);
            for(let i=0;i<outH;i++)
                tempOutImage[i] = new Array(outW);
            
            //임시 입력 배열 초기화(127로, 평균값, 인접값*)
            for (let i=0;i<inH+2;i++)
                for (let k=0;k<inW+2;k++)
                    tempInImage[i][k] = 127.0;
            //입력 이미지 > 임시 입력 이미지의 중간에 쏙
            for (let i=0;i<inH;i++)
                for (let k=0;k<inW;k++)
                    tempInImage[i+1][k+1] = inImage[i][k];
    
            //영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for (let i=0;i<inH;i++){
                for (let k=0;k<inW;k++){
                    //한점 처리
                    let S = 0.0; //9점을 곱해서 합한 결과
                    for (let m=0; m<3; m++)
                        for(let n=0; n<3; n++)
                            S += tempInImage[i+m][k+n] * mask[m][n];
                    tempOutImage[i][k] = S;
                }
            //*********************************
            }
            // //후처리 작업 (마스크의 합계가 0이면 127정도를 더해주기를 고려)
            // for (let i=0;i<outH;i++)
            //     for (let k=0;k<outW;k++)
            //         tempOutImage[i][k] += 127.0;
    
            // 임시 출력 이미지 --> 원 출력 이미지
            for (let i=0;i<outH;i++)
                for (let k=0;k<outW;k++) {
                    if (tempOutImage[i][k] > 255.0)
                        outImage[i][k] = 255;
                    else if (tempOutImage[i][k] < 0.0)
                        outImage[i][k] = 0;
                    
                    else
                        outImage[i][k] = parseInt(tempOutImage[i][k]);
                }
            displayImage();
        }
    
    
        function edgeImage() {  //엣지 검출 알고리즘 -->수직,수평 합
            // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
            outH = inH;
            outW = inW;
            //출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0;i<outH;i++)
                outImage[i] = new Array(outW);
            // ****진짜 영상처리 알고리즘*****
            //(짱 중요함) -->마스크를 선택
            let mask = [    [ 0.0 , -1.0, 0.0], 
                            [-1.0 ,  2.0, 0.0], 
                            [ 0.0 ,  0.0, 0.0]
                        ];
            //임시 입력 배열 (입력배열 +2)
            let tempInImage = new Array(inH+2);
            for(let i=0; i<inH+2;i++)
                tempInImage[i] =  new Array(inW+2);
    
            //임시 출력 배열 (출력배열과 크기 동일)
            let tempOutImage = new Array(outH);
            for(let i=0;i<outH;i++)
                tempOutImage[i] = new Array(outW);
            
            //임시 입력 배열 초기화(127로, 평균값, 인접값*)
            for (let i=0;i<inH+2;i++)
                for (let k=0;k<inW+2;k++)
                    tempInImage[i][k] = 127.0;
            //입력 이미지 > 임시 입력 이미지의 중간에 쏙
            for (let i=0;i<inH;i++)
                for (let k=0;k<inW;k++)
                    tempInImage[i+1][k+1] = inImage[i][k];
    
            //영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for (let i=0;i<inH;i++){
                for (let k=0;k<inW;k++){
                    //한점 처리
                    let S = 0.0; //9점을 곱해서 합한 결과
                    for (let m=0; m<3; m++)
                        for(let n=0; n<3; n++)
                            S += tempInImage[i+m][k+n] * mask[m][n];
                    tempOutImage[i][k] = S;
                }
            //*********************************
            }
            // //후처리 작업 (마스크의 합계가 0이면 127정도를 더해주기를 고려)
            // for (let i=0;i<outH;i++)
            //     for (let k=0;k<outW;k++)
            //         tempOutImage[i][k] += 127.0;
    
            // 임시 출력 이미지 --> 원 출력 이미지
            for (let i=0;i<outH;i++)
                for (let k=0;k<outW;k++) 
                    outImage[i][k] = parseInt(tempOutImage[i][k]);
                
            displayImage();
        }
    
        function laplaImage() {  //엣지 검출 알고리즘 -->라플라시안
            // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
            outH = inH;
            outW = inW;
            //출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0;i<outH;i++)
                outImage[i] = new Array(outW);
            // ****진짜 영상처리 알고리즘*****
            //(짱 중요함) -->마스크를 선택
            let mask = [    [ 0.0 , -1.0, 0.0], 
                            [-1.0 ,  4.0, -1.0], 
                            [ 0.0 ,  -1.0, 0.0]
                        ];
            //임시 입력 배열 (입력배열 +2)
            let tempInImage = new Array(inH+2);
            for(let i=0; i<inH+2;i++)
                tempInImage[i] =  new Array(inW+2);
    
            //임시 출력 배열 (출력배열과 크기 동일)
            let tempOutImage = new Array(outH);
            for(let i=0;i<outH;i++)
                tempOutImage[i] = new Array(outW);
            
            //임시 입력 배열 초기화(127로, 평균값, 인접값*)
            for (let i=0;i<inH+2;i++)
                for (let k=0;k<inW+2;k++)
                    tempInImage[i][k] = 127.0;
            //입력 이미지 > 임시 입력 이미지의 중간에 쏙
            for (let i=0;i<inH;i++)
                for (let k=0;k<inW;k++)
                    tempInImage[i+1][k+1] = inImage[i][k];
    
            //영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for (let i=0;i<inH;i++){
                for (let k=0;k<inW;k++){
                    //한점 처리
                    let S = 0.0; //9점을 곱해서 합한 결과
                    for (let m=0; m<3; m++)
                        for(let n=0; n<3; n++)
                            S += tempInImage[i+m][k+n] * mask[m][n];
                    tempOutImage[i][k] = S;
                }
            //*********************************
            }
            // //후처리 작업 (마스크의 합계가 0이면 127정도를 더해주기를 고려)
            // for (let i=0;i<outH;i++)
            //     for (let k=0;k<outW;k++)
            //         tempOutImage[i][k] += 127.0;
    
            // 임시 출력 이미지 --> 원 출력 이미지
            for (let i=0;i<outH;i++)
                for (let k=0;k<outW;k++) 
                    outImage[i][k] = parseInt(tempOutImage[i][k]);
                
            displayImage();
        }
    
        function LoGImage() {  //엣지 검출 알고리즘 -->Laplacian of Gaussian
            //(중요!) 출력이미지의 크기가 결정--> 알고리즘에 의존
            outH=inH;
                    outW=inW;
                    //출력 영상의 2차원 메모리 할당
                    outImage = new Array(outH);
                        for (let i = 0; i < outH; i++)
                            outImage[i] = new Array(outW);
                    //진짜 영상처리 알고리즘 ***
                    //(짱! 중요) --> 마스크를 선택
                    let mask = [
                                [0.0,0.0,-1.0,0.0,0.0],
                                [0.0,-1.0,-2.0,-1.0,0.0],
                                [-1.0,-2.0,16.0,-2.0,-1.0],
                                [0.0,-1.0,-2.0,-1.0,0.0],
                                [0.0,0.0,-1.0,0.0,0.0]
                            ];
                    //임시 입력 배열(입력배열 + 2)
                    let tmpInImage = new Array(inH+4);
                    for(let i=0;i<inH+4;i++)
                        tmpInImage[i]= new Array(inW+4);
                    
                    //임시 출력 배열 (출력배열과 크기 동일)
                    let tmpOutImage = new Array(outH);
                        for (let i = 0; i < outH; i++)
                            tmpOutImage[i] = new Array(outW);
                    //임시 입력 배열 초기화(127로, 평균값, 인접값*)
                    for(let i=0;i<inH+4;i++)
                        for(let k=0;k<inW+4;k++)
                            tmpInImage[i][k]=127.0;
    
                    //입력 이미지 => 임시 입력 이미지의 중간에 쏙~
                    for(let i=0;i<inH;i++)
                        for(let k=0;k<inW;k++)
                            tmpInImage[i+2][k+2]=inImage[i][k];
                    //영상처리 알고리즘 --> 회선 연산(=긁어가기)
                    for(let i=0;i<inH;i++){
                        for(let k=0;k<inW;k++){
                            //한점처리
                            let S = 0.0;//9점을 곱해서 합한 결과
                            for(let m=0;m<5;m++)
                                for(let n=0;n<5;n++)
                                    S += tmpInImage[i+m][k+n]*mask[m][n];
                            tmpOutImage[i][k]=S;
                        }
                    }
                    //후처리 작업 (마스크의 합계가 0이면 127정도를 더해주기를 고려)
                    for(let i=0;i<outH;i++)
                        for(let k=0;k<outW;k++)
                            tmpOutImage[i][k]+=127.0;
                    //임시 출력이미지 --> 원 출력이미지
                    for(let i=0;i<outH;i++)
                        for(let k=0;k<outW;k++){
                            if(tmpOutImage[i][k] > 255.0)
                                outImage[i][k]=255;
                            else if(tmpOutImage[i][k] < 0.0)
                                outImage[i][k]=0;
                            else
                                outImage[i][k]=parseInt(tmpOutImage[i][k]);
                        }
                    //
                    displayImage();
    
                }
                
            
        
    
        function DoGImage() {  //엣지 검출 알고리즘 -->수직,수평 합
            // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
            outH = inH;
            outW = inW;
            //출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0;i<outH;i++)
                outImage[i] = new Array(outW);
            // ****진짜 영상처리 알고리즘*****
            //(짱 중요함) -->마스크를 선택
            let mask = [    [ 0.0 , 0.0, 0.0, -1.0, -1.0, -1.0, 0.0, 0.0, 0.0], 
                            [ 0.0 , -2.0, -3.0 , -3.0 ,-3.0 ,- 3.0 , -3.0 ,-2.0 ,0.0], 
                            [ 0.0 ,  -3.0, -2.0, -1.0, -1.0, -1.0, -2.0,-3.0, 0.0],
                            [-1.0, -3.0, -1.0, 9.0, 9.0, 9.0, -1.0, -3.0, -1.0],
                            [-1.0, -3.0, -1.0, 9.0, 19.0, 9.0, -1.0, -3.0, -1.0],
                            [-1.0, -3.0, -1.0, 9.0, 9.0, 9.0, -1.0, -3.0, -1.0],
                            [ 0.0 ,  -3.0, -2.0, -1.0, -1.0, -1.0, -2.0,-3.0, 0.0],
                            [ 0.0 , -2.0, -3.0 , -3.0 ,-3.0 ,- 3.0 , -3.0 ,-2.0 ,0.0],
                            [ 0.0 , 0.0, 0.0, -1.0, -1.0, -1.0, 0.0, 0.0, 0.0]
                        ];
            //임시 입력 배열 (입력배열 +2)
            let tempInImage = new Array(inH+8);
            for(let i=0; i<inH+8;i++)
                tempInImage[i] =  new Array(inW+8);
    
            //임시 출력 배열 (출력배열과 크기 동일)
            let tempOutImage = new Array(outH);
            for(let i=0;i<outH;i++)
                tempOutImage[i] = new Array(outW);
            
            //임시 입력 배열 초기화(127로, 평균값, 인접값*)
            for (let i=0;i<inH+8;i++)
                for (let k=0;k<inW+8;k++)
                    tempInImage[i][k] = 127.0;
            //입력 이미지 > 임시 입력 이미지의 중간에 쏙
            for (let i=0;i<inH;i++)
                for (let k=0;k<inW;k++)
                    tempInImage[i+4][k+4] = inImage[i][k];
    
            //영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for (let i=0;i<inH;i++){
                for (let k=0;k<inW;k++){
                    //한점 처리
                    let S = 0.0; //9점을 곱해서 합한 결과
                    for (let m=0; m<9; m++)
                        for(let n=0; n<9; n++)
                            S += tempInImage[i+m][k+n] * mask[m][n];
                    tempOutImage[i][k] = S;
                }
            //*********************************
            }
            //후처리 작업 (마스크의 합계가 0이면 127정도를 더해주기를 고려)
            for (let i=0;i<outH;i++)
                for (let k=0;k<outW;k++)
                    tempOutImage[i][k] += 127.0;
    
            // 임시 출력 이미지 --> 원 출력 이미지
            for (let i=0;i<outH;i++)
                for (let k=0;k<outW;k++) {
                    if (tempOutImage[i][k] > 255.0)
                        outImage[i][k] = 255;
                    else if (tempOutImage[i][k] < 0.0)
                        outImage[i][k] = 0;
                    
                    else
                        outImage[i][k] = parseInt(tempOutImage[i][k]);
                }
                
            displayImage();
        }
    
        function stretchImage() { // 히스토그램 스트래칭 알고리즘
                // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
                outH = inH;
                outW = inW;
                // 출력 영상의 2차원 메모리 할당
                outImage = new Array(outH);
                for(let i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                // **** 진짜 영상처리 알고리즘 *****
                // 공식 : out = (in - LOW) / (HIGH - LOW) * 255.0
                let LOW = inImage[0][0], HIGH = inImage[0][0];
                for (let i=0; i<inH; i++) 
                    for (let k=0; k<inW; k++) {
                        if (LOW > inImage[i][k])
                            LOW = inImage[i][k];
                        if (HIGH < inImage[i][k])
                            HIGH = inImage[i][k];
                    }
    
                for (let i=0; i<inH; i++) {
                    for (let k=0; k<inW; k++) {
                        let out =  (inImage[i][k] - LOW) / (HIGH - LOW) * 255.0;
                        //오버플로우 방지
                        if (out < 0.0)
                            out = 0;
                        else if (out > 255.0)
                            out = 255;
                        else 
                            out = parseInt(out);
    
                        outImage[i][k] = out;
                    }
                }
                // ******************************
                displayImage();
            }
    
            function equalizeImage() { // 히스토그램 평활화 알고리즘
                // (중요!) 출력 이미지의 크기가 결정(->메모리 확보를 위함)-->알고리즘에 의존..
                outH = inH;
                outW = inW;
                //출력 영상의 2차원 메모리 할당
                outImage = new Array(outH);
                for(let i=0;i<outH;i++)
                    outImage[i] = new Array(outW);
                // ****진짜 영상처리 알고리즘*****
                // 1단계 : 히스토그램 생성
                    let histo = new Array(256);
                    //초기화
                    for (let i=0; i<256;i++)
                        histo[i] =0;
                    //카운트
                    for (let i=0;i<inH;i++)
                        for (let k=0;k<inW;k++)
                            histo[inImage[i][k]] ++;
                // 2단계 : 누적히스토그램 생성
                    let sumHisto =  new Array(256);
                    //초기화
                    for(let i=0; i<256;i++)
                        sumHisto[i] = 0;
                    //계산
                    let sumValue =0;
                    for (let i=0; i<256; i++) {
                        sumValue += histo[i];
                        sumHisto[i] = sumValue;
                    }
                // 3단계 : 정규화된 누적 히스토그램 생성
                // 공식 : normal = sum * (1/ (inH*inW) ) * 255;
                let normalHisto =  new Array(256);
                    //초기화
                    for(let i=0; i<256;i++)
                        normalHisto[i] = 0.0;
                    //계산
                    for(let i=0; i<256;i++){
                        let normal = sumHisto[i] * (1.0/(inH*inW)) * 255.0;
                        normalHisto[i] = normal;
                    }
                    //영상처리
                    for (let i=0;i<inH;i++){
                        for (let k=0;k<inW;k++){
                            outImage[i][k] = parseInt(normalHisto[inImage[i][k]]);
                        }
                //*********************************
                }displayImage();
            }
        </script>
    </head>
    <body onload="init()">
        <!-- Responsive navbar-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
            <div class="container px-5">
                <a class="navbar-brand" href="#!"></a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
                        <li class="nav-item"><a class="nav-link" aria-current="page" href="pixel.html">화소점 처리</a></li>
                        <li class="nav-item"><a class="nav-link" href="geometry.html">기하학 처리</a></li>
                        <li class="nav-item"><a class="nav-link active" href="area.html">화소영역 처리</a></li>
                        <li class="nav-item"><a class="nav-link" href="histo.html">히스토그램</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Page Content-->
    
        <header class="py-5 bg-light border-bottom mb-4">
            <div class="container">
                <div class="text-center my-5">
                    <h1 class="fw-bolder">영상처리 알고리즘</h1>
                    <p class="lead mb-0">영상 처리 알고리즘의 종류에 대해 설명</p>
                </div>
            </div>
        </header>
        <div class="container px-4 px-lg-5">
            <!-- Heading Row-->
            <form>
                <div class="btn-group" role="group" aria-label="..." margin: auto;>
                    <button type="button" class="btn btn-default" onclick="embossImage()">엠보싱</button>
                    <button type="button" class="btn btn-default" onclick="blurImage()">블러링</button>
                    <button type="button" class="btn btn-default" onclick="gaussianImage()">가우시안</button>
                    <button type="button" class="btn btn-default" onclick="sharpImage()">샤프닝</button>
                    <button type="button" class="btn btn-default" onclick="onHpfSharpImage()">고주파 필터 샤프닝</button>
                    <button type="button" class="btn btn-default" onclick="edgeImage()">엣지(이동과 차분)</button>
                    <button type="button" class="btn btn-default" onclick="laplaImage()">엣지(라플라시안)</button>
                    <button type="button" class="btn btn-default" onclick="LoGImage()">엣지(LoG)</button>
                    <button type="button" class="btn btn-default" onclick="DoGImage()">엣지(Dog)</button>
                </div>
                <div class="row gx-4 gx-lg-5 align-items-center my-5">
                  
                    <div class="col-lg-7">
                        <canvas id="inCanvas" style="background-color:beige;" width="300" height="300"></canvas>
                        <canvas id="outCanvas" style="background-color:darkblue;" width="300" height="300"></canvas>
                    </div>
                    <div class="col-lg-5">
                        <h1 class="font-weight-light">화소 영역 처리</h1>
                        <p>This is a template that is great for small businesses. It doesn't have too much fancy flare to it, but it makes a great use of the standard Bootstrap core components. Feel free to use this template for any project you want!</p>
                        <a class="btn btn-primary" href="#!">
                            <input type="file" value="file" id="inFile" onchange="openImage()"/><br></a>
            </form>
        </div>

        
            </form>
        </div>

        </div>
        <!-- Footer-->
        <footer class="py-5 bg-dark">
            <div class="container px-4 px-lg-5"><p class="m-0 text-center text-white">Copyright &copy; Your Website 2022</p></div>
        </footer>


    </body>
</html>
